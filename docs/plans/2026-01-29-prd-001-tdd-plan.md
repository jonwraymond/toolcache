# toolcache TDD Implementation Plan

> **For agents:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**PRD Reference:** `2026-01-29-prd-001-toolcache-library.md`
**Execution Plan:** `2026-01-29-prd-001-execution-plan.md`
**Status:** Ready for Implementation
**Date:** 2026-01-29

---

## TDD Philosophy

Each task follows strict Red-Green-Refactor:

1. **Red** — Write failing test(s) that define expected behavior
2. **Verify Red** — Run test, confirm it fails for the right reason
3. **Green** — Write minimal implementation to pass
4. **Verify Green** — Run test, confirm pass
5. **Refactor** — Clean up while keeping tests green
6. **Commit** — One atomic commit per task

---

## Detailed Contracts

### Cache Keying Contract

**Format:** `toolcache:<toolID>:<hash>`

| Component | Description | Example |
|-----------|-------------|---------|
| `toolcache` | Static prefix for namespace isolation | `toolcache` |
| `toolID` | Qualified tool identifier `namespace:name` | `myns:read_file` |
| `hash` | SHA-256 of canonical JSON (first 16 hex chars) | `a1b2c3d4e5f6g7h8` |

**Canonical JSON Rules:**
- Object keys: sorted lexicographically (ascending)
- Map iteration: deterministic via sorted keys
- Arrays: preserve insertion order
- Null values: included as `null`
- Numbers: no trailing zeros, no leading zeros (except 0.x)
- Strings: UTF-8, escaped per JSON spec

**Key Guarantees:**
```go
// Same inputs MUST produce same key
Key("ns:tool", map[string]any{"b": 2, "a": 1}) == Key("ns:tool", map[string]any{"a": 1, "b": 2})

// Different inputs MUST produce different keys
Key("ns:tool", map[string]any{"a": 1}) != Key("ns:tool", map[string]any{"a": 2})

// Tool ID is part of key (different tools, same input = different key)
Key("ns:toolA", input) != Key("ns:toolB", input)
```

---

### TTL Policy Contract

```go
type Policy struct {
    DefaultTTL  time.Duration // Applied when no override given (0 = no caching)
    MaxTTL      time.Duration // Upper bound for any TTL (0 = unlimited)
    AllowUnsafe bool          // If false, skip tools tagged "write", "danger", "unsafe"
}
```

**TTL Resolution Order:**
1. Per-call override (if provided and > 0)
2. Clamped to `MaxTTL` (if MaxTTL > 0)
3. Fall back to `DefaultTTL` (if no override)
4. `0` means "do not cache"

**TTL Behavior Matrix:**

| DefaultTTL | Override | MaxTTL | Effective TTL |
|------------|----------|--------|---------------|
| 5m         | 0        | 0      | 5m (default)  |
| 5m         | 10m      | 0      | 10m (override)|
| 5m         | 10m      | 7m     | 7m (clamped)  |
| 0          | 0        | 0      | 0 (no cache)  |
| 0          | 5m       | 0      | 5m (override) |

---

### Skip Rules Contract

**Default Skip Tags:** `write`, `danger`, `unsafe`, `mutation`, `delete`

**Skip Evaluation:**
```go
// SkipRule determines if a tool should bypass caching
type SkipRule func(toolID string, tags []string) bool

// DefaultSkipRule skips tools with unsafe tags
func DefaultSkipRule(toolID string, tags []string) bool {
    unsafeTags := []string{"write", "danger", "unsafe", "mutation", "delete"}
    for _, tag := range tags {
        for _, unsafe := range unsafeTags {
            if strings.EqualFold(tag, unsafe) {
                return true // skip caching
            }
        }
    }
    return false // cache allowed
}
```

**Skip Rule Precedence:**
1. If `Policy.AllowUnsafe == true`, skip rules are ignored
2. If custom `SkipRule` provided, use it exclusively
3. Else use `DefaultSkipRule`

---

## Task Breakdown with Tests

### Task 0 — Module Scaffolding (Already Complete)

**Status:** Done (go.mod, doc.go exist)

**Verification:**
```bash
cd toolcache && go build ./...
```

---

### Task 1 — Core Interfaces + Errors

**Files:** `cache.go`, `cache_test.go`

**Interface Definition:**
```go
// Cache provides the core caching interface.
type Cache interface {
    // Get retrieves a value. Returns (nil, false) on miss.
    Get(ctx context.Context, key string) (value []byte, ok bool)
    
    // Set stores a value with TTL. TTL of 0 means use policy default.
    Set(ctx context.Context, key string, value []byte, ttl time.Duration) error
    
    // Delete removes a key. No error if key doesn't exist.
    Delete(ctx context.Context, key string) error
}

// Sentinel errors
var (
    ErrNilCache     = errors.New("toolcache: cache is nil")
    ErrInvalidKey   = errors.New("toolcache: key is invalid")
    ErrKeyTooLong   = errors.New("toolcache: key exceeds max length")
)

const MaxKeyLength = 512
```

**Tests:**

```go
func TestCacheErrors_NilCache(t *testing.T) {
    // Verify that operations on nil cache return ErrNilCache
    var c Cache = nil
    // Note: This tests the SafeCache wrapper behavior
}

func TestCacheInterface_BasicContract(t *testing.T) {
    // Verify interface methods exist and have correct signatures
    // This is a compile-time check enforced by implementing a mock
}

func TestCacheKey_Validation(t *testing.T) {
    tests := []struct {
        name    string
        key     string
        wantErr error
    }{
        {"empty key", "", ErrInvalidKey},
        {"valid key", "toolcache:ns:tool:abc123", nil},
        {"too long", strings.Repeat("x", MaxKeyLength+1), ErrKeyTooLong},
        {"contains newline", "key\nwith\nnewlines", ErrInvalidKey},
    }
    // Run subtests
}
```

**Commit:** `feat(toolcache): add cache interface and errors`

---

### Task 2 — Deterministic Keyer

**Files:** `keyer.go`, `keyer_test.go`

**Interface Definition:**
```go
// Keyer generates deterministic cache keys from tool inputs.
type Keyer interface {
    // Key generates a cache key for the given tool and input.
    // The key MUST be deterministic: same inputs = same key.
    Key(toolID string, input any) (string, error)
}

// DefaultKeyer implements Keyer using canonical JSON + SHA-256.
type DefaultKeyer struct{}
```

**Tests:**

```go
func TestKeyer_DeterministicForMaps(t *testing.T) {
    k := NewDefaultKeyer()
    
    // Different key order, same content
    input1 := map[string]any{"z": 1, "a": 2, "m": 3}
    input2 := map[string]any{"a": 2, "m": 3, "z": 1}
    
    key1, err1 := k.Key("ns:tool", input1)
    key2, err2 := k.Key("ns:tool", input2)
    
    require.NoError(t, err1)
    require.NoError(t, err2)
    require.Equal(t, key1, key2, "same content must produce same key")
}

func TestKeyer_ArrayOrderPreserved(t *testing.T) {
    k := NewDefaultKeyer()
    
    input1 := map[string]any{"items": []int{1, 2, 3}}
    input2 := map[string]any{"items": []int{3, 2, 1}}
    
    key1, _ := k.Key("ns:tool", input1)
    key2, _ := k.Key("ns:tool", input2)
    
    require.NotEqual(t, key1, key2, "different array order must produce different keys")
}

func TestKeyer_SameInputsSameKey(t *testing.T) {
    k := NewDefaultKeyer()
    
    // Multiple calls with identical input
    input := map[string]any{"path": "/tmp/file", "mode": "read"}
    
    key1, _ := k.Key("ns:read_file", input)
    key2, _ := k.Key("ns:read_file", input)
    key3, _ := k.Key("ns:read_file", input)
    
    require.Equal(t, key1, key2)
    require.Equal(t, key2, key3)
}

func TestKeyer_DifferentToolsDifferentKeys(t *testing.T) {
    k := NewDefaultKeyer()
    input := map[string]any{"path": "/tmp/file"}
    
    key1, _ := k.Key("ns:toolA", input)
    key2, _ := k.Key("ns:toolB", input)
    
    require.NotEqual(t, key1, key2, "different tools must produce different keys")
}

func TestKeyer_KeyFormat(t *testing.T) {
    k := NewDefaultKeyer()
    key, _ := k.Key("myns:mytool", map[string]any{"a": 1})
    
    // Verify format: toolcache:<toolID>:<hash>
    require.True(t, strings.HasPrefix(key, "toolcache:myns:mytool:"))
    
    parts := strings.Split(key, ":")
    require.Len(t, parts, 4) // toolcache, myns, mytool, hash
    require.Len(t, parts[3], 16) // 16 hex chars
}

func TestKeyer_NestedMaps(t *testing.T) {
    k := NewDefaultKeyer()
    
    // Nested maps with different insertion order
    input1 := map[string]any{
        "outer": map[string]any{"b": 2, "a": 1},
    }
    input2 := map[string]any{
        "outer": map[string]any{"a": 1, "b": 2},
    }
    
    key1, _ := k.Key("ns:tool", input1)
    key2, _ := k.Key("ns:tool", input2)
    
    require.Equal(t, key1, key2)
}

func TestKeyer_NilInput(t *testing.T) {
    k := NewDefaultKeyer()
    
    key1, err1 := k.Key("ns:tool", nil)
    key2, err2 := k.Key("ns:tool", nil)
    
    require.NoError(t, err1)
    require.NoError(t, err2)
    require.Equal(t, key1, key2)
}

func TestKeyer_EmptyInput(t *testing.T) {
    k := NewDefaultKeyer()
    
    keyEmpty, _ := k.Key("ns:tool", map[string]any{})
    keyNil, _ := k.Key("ns:tool", nil)
    
    // Empty map and nil should produce different keys
    require.NotEqual(t, keyEmpty, keyNil)
}
```

**Commit:** `feat(toolcache): add deterministic keyer`

---

### Task 3 — TTL Policy

**Files:** `policy.go`, `policy_test.go`

**Type Definition:**
```go
// Policy controls TTL and cache behavior.
type Policy struct {
    DefaultTTL  time.Duration
    MaxTTL      time.Duration
    AllowUnsafe bool
}

// EffectiveTTL computes the TTL to use given an override.
func (p Policy) EffectiveTTL(override time.Duration) time.Duration

// ShouldCache determines if caching is allowed for this policy.
func (p Policy) ShouldCache() bool

// DefaultPolicy returns a reasonable default policy.
func DefaultPolicy() Policy {
    return Policy{
        DefaultTTL:  5 * time.Minute,
        MaxTTL:      1 * time.Hour,
        AllowUnsafe: false,
    }
}

// NoCachePolicy returns a policy that disables caching.
func NoCachePolicy() Policy {
    return Policy{DefaultTTL: 0}
}
```

**Tests:**

```go
func TestPolicy_DefaultTTL(t *testing.T) {
    p := Policy{DefaultTTL: 5 * time.Minute}
    
    // No override: use default
    require.Equal(t, 5*time.Minute, p.EffectiveTTL(0))
}

func TestPolicy_OverrideTTL(t *testing.T) {
    p := Policy{DefaultTTL: 5 * time.Minute}
    
    // Override provided: use override
    require.Equal(t, 10*time.Minute, p.EffectiveTTL(10*time.Minute))
}

func TestPolicy_MaxTTLClamping(t *testing.T) {
    p := Policy{
        DefaultTTL: 5 * time.Minute,
        MaxTTL:     7 * time.Minute,
    }
    
    // Override exceeds max: clamp to max
    require.Equal(t, 7*time.Minute, p.EffectiveTTL(10*time.Minute))
    
    // Override under max: use override
    require.Equal(t, 3*time.Minute, p.EffectiveTTL(3*time.Minute))
}

func TestPolicy_DisabledCaching(t *testing.T) {
    p := Policy{DefaultTTL: 0}
    
    require.False(t, p.ShouldCache())
    require.Equal(t, time.Duration(0), p.EffectiveTTL(0))
}

func TestPolicy_OverrideEnablesCaching(t *testing.T) {
    p := Policy{DefaultTTL: 0} // Caching disabled by default
    
    // Override can enable caching even if default is 0
    require.Equal(t, 5*time.Minute, p.EffectiveTTL(5*time.Minute))
}

func TestPolicy_DefaultPolicy(t *testing.T) {
    p := DefaultPolicy()
    
    require.Equal(t, 5*time.Minute, p.DefaultTTL)
    require.Equal(t, 1*time.Hour, p.MaxTTL)
    require.False(t, p.AllowUnsafe)
}

func TestPolicy_NoCachePolicy(t *testing.T) {
    p := NoCachePolicy()
    
    require.Equal(t, time.Duration(0), p.DefaultTTL)
    require.False(t, p.ShouldCache())
}

func TestPolicy_TTLMatrix(t *testing.T) {
    tests := []struct {
        name       string
        policy     Policy
        override   time.Duration
        wantTTL    time.Duration
    }{
        {"default only", Policy{DefaultTTL: 5 * time.Minute}, 0, 5 * time.Minute},
        {"override wins", Policy{DefaultTTL: 5 * time.Minute}, 10 * time.Minute, 10 * time.Minute},
        {"clamped to max", Policy{DefaultTTL: 5 * time.Minute, MaxTTL: 7 * time.Minute}, 10 * time.Minute, 7 * time.Minute},
        {"no cache default", Policy{DefaultTTL: 0}, 0, 0},
        {"override enables", Policy{DefaultTTL: 0}, 5 * time.Minute, 5 * time.Minute},
        {"max zero means unlimited", Policy{DefaultTTL: 5 * time.Minute, MaxTTL: 0}, 1 * time.Hour, 1 * time.Hour},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := tt.policy.EffectiveTTL(tt.override)
            require.Equal(t, tt.wantTTL, got)
        })
    }
}
```

**Commit:** `feat(toolcache): add ttl policy`

---

### Task 4 — In-memory Backend

**Files:** `memory.go`, `memory_test.go`

**Type Definition:**
```go
// MemoryCache is a thread-safe in-memory cache implementation.
type MemoryCache struct {
    mu      sync.RWMutex
    entries map[string]*cacheEntry
    policy  Policy
}

type cacheEntry struct {
    value     []byte
    expiresAt time.Time
}

// NewMemoryCache creates a new in-memory cache with the given policy.
func NewMemoryCache(policy Policy) *MemoryCache

// Ensure MemoryCache implements Cache
var _ Cache = (*MemoryCache)(nil)
```

**Tests:**

```go
func TestMemoryCache_GetSetDelete(t *testing.T) {
    c := NewMemoryCache(DefaultPolicy())
    ctx := context.Background()
    
    // Set
    err := c.Set(ctx, "key1", []byte("value1"), 5*time.Minute)
    require.NoError(t, err)
    
    // Get hit
    val, ok := c.Get(ctx, "key1")
    require.True(t, ok)
    require.Equal(t, []byte("value1"), val)
    
    // Get miss
    _, ok = c.Get(ctx, "nonexistent")
    require.False(t, ok)
    
    // Delete
    err = c.Delete(ctx, "key1")
    require.NoError(t, err)
    
    // Verify deleted
    _, ok = c.Get(ctx, "key1")
    require.False(t, ok)
    
    // Delete nonexistent (no error)
    err = c.Delete(ctx, "nonexistent")
    require.NoError(t, err)
}

func TestMemoryCache_Expiry(t *testing.T) {
    c := NewMemoryCache(Policy{DefaultTTL: 50 * time.Millisecond})
    ctx := context.Background()
    
    // Set with short TTL
    err := c.Set(ctx, "key1", []byte("value1"), 50*time.Millisecond)
    require.NoError(t, err)
    
    // Immediate get: hit
    val, ok := c.Get(ctx, "key1")
    require.True(t, ok)
    require.Equal(t, []byte("value1"), val)
    
    // Wait for expiry
    time.Sleep(60 * time.Millisecond)
    
    // After expiry: miss
    _, ok = c.Get(ctx, "key1")
    require.False(t, ok, "expired entry should not be returned")
}

func TestMemoryCache_ConcurrentAccess(t *testing.T) {
    c := NewMemoryCache(DefaultPolicy())
    ctx := context.Background()
    
    const numGoroutines = 100
    const numOps = 1000
    
    var wg sync.WaitGroup
    wg.Add(numGoroutines)
    
    for i := 0; i < numGoroutines; i++ {
        go func(id int) {
            defer wg.Done()
            for j := 0; j < numOps; j++ {
                key := fmt.Sprintf("key-%d-%d", id, j%10)
                value := []byte(fmt.Sprintf("value-%d-%d", id, j))
                
                // Mix of operations
                switch j % 3 {
                case 0:
                    c.Set(ctx, key, value, time.Minute)
                case 1:
                    c.Get(ctx, key)
                case 2:
                    c.Delete(ctx, key)
                }
            }
        }(i)
    }
    
    wg.Wait()
    // Test passes if no race conditions detected (run with -race)
}

func TestMemoryCache_SetOverwrite(t *testing.T) {
    c := NewMemoryCache(DefaultPolicy())
    ctx := context.Background()
    
    c.Set(ctx, "key", []byte("value1"), time.Minute)
    c.Set(ctx, "key", []byte("value2"), time.Minute)
    
    val, ok := c.Get(ctx, "key")
    require.True(t, ok)
    require.Equal(t, []byte("value2"), val)
}

func TestMemoryCache_ZeroTTL(t *testing.T) {
    c := NewMemoryCache(Policy{DefaultTTL: 0})
    ctx := context.Background()
    
    // TTL of 0 means immediate expiry (no caching)
    err := c.Set(ctx, "key", []byte("value"), 0)
    require.NoError(t, err)
    
    // Should not be retrievable
    _, ok := c.Get(ctx, "key")
    require.False(t, ok, "zero TTL should mean no caching")
}

func TestMemoryCache_NilValue(t *testing.T) {
    c := NewMemoryCache(DefaultPolicy())
    ctx := context.Background()
    
    // Storing nil is valid (represents cached "no result")
    err := c.Set(ctx, "key", nil, time.Minute)
    require.NoError(t, err)
    
    val, ok := c.Get(ctx, "key")
    require.True(t, ok)
    require.Nil(t, val)
}

func TestMemoryCache_ContextCancellation(t *testing.T) {
    c := NewMemoryCache(DefaultPolicy())
    ctx, cancel := context.WithCancel(context.Background())
    cancel() // Cancel immediately
    
    // Operations should still work (context is advisory)
    err := c.Set(ctx, "key", []byte("value"), time.Minute)
    require.NoError(t, err)
    
    val, ok := c.Get(ctx, "key")
    require.True(t, ok)
    require.Equal(t, []byte("value"), val)
}

func TestMemoryCache_LargeValues(t *testing.T) {
    c := NewMemoryCache(DefaultPolicy())
    ctx := context.Background()
    
    // 1MB value
    largeValue := make([]byte, 1024*1024)
    for i := range largeValue {
        largeValue[i] = byte(i % 256)
    }
    
    err := c.Set(ctx, "large", largeValue, time.Minute)
    require.NoError(t, err)
    
    val, ok := c.Get(ctx, "large")
    require.True(t, ok)
    require.Equal(t, largeValue, val)
}
```

**Commit:** `feat(toolcache): add in-memory backend`

---

### Task 5 — Middleware (Skip Rules)

**Files:** `middleware.go`, `middleware_test.go`

**Type Definition:**
```go
// SkipRule determines if a tool should bypass caching.
// Returns true to skip caching, false to allow caching.
type SkipRule func(toolID string, tags []string) bool

// DefaultUnsafeTags are skipped by default.
var DefaultUnsafeTags = []string{"write", "danger", "unsafe", "mutation", "delete"}

// DefaultSkipRule skips tools with unsafe tags.
func DefaultSkipRule(toolID string, tags []string) bool

// ToolExecutor represents a function that executes a tool.
type ToolExecutor func(ctx context.Context, toolID string, input any) ([]byte, error)

// CacheMiddleware wraps a ToolExecutor with caching behavior.
type CacheMiddleware struct {
    cache    Cache
    keyer    Keyer
    policy   Policy
    skipRule SkipRule
}

// NewCacheMiddleware creates middleware with the given dependencies.
func NewCacheMiddleware(cache Cache, keyer Keyer, policy Policy, skipRule SkipRule) *CacheMiddleware

// Wrap returns a cached version of the executor.
func (m *CacheMiddleware) Wrap(executor ToolExecutor) ToolExecutor

// Execute runs the tool with caching, using the provided tags for skip evaluation.
func (m *CacheMiddleware) Execute(ctx context.Context, toolID string, input any, tags []string, executor ToolExecutor) ([]byte, error)
```

**Tests:**

```go
func TestMiddleware_CacheHit(t *testing.T) {
    cache := NewMemoryCache(DefaultPolicy())
    keyer := NewDefaultKeyer()
    policy := DefaultPolicy()
    mw := NewCacheMiddleware(cache, keyer, policy, nil)
    
    ctx := context.Background()
    callCount := 0
    executor := func(ctx context.Context, toolID string, input any) ([]byte, error) {
        callCount++
        return []byte("result"), nil
    }
    
    // First call: cache miss, executor called
    result1, err := mw.Execute(ctx, "ns:tool", map[string]any{"a": 1}, nil, executor)
    require.NoError(t, err)
    require.Equal(t, []byte("result"), result1)
    require.Equal(t, 1, callCount)
    
    // Second call: cache hit, executor NOT called
    result2, err := mw.Execute(ctx, "ns:tool", map[string]any{"a": 1}, nil, executor)
    require.NoError(t, err)
    require.Equal(t, []byte("result"), result2)
    require.Equal(t, 1, callCount, "executor should not be called on cache hit")
}

func TestMiddleware_CacheMiss(t *testing.T) {
    cache := NewMemoryCache(DefaultPolicy())
    keyer := NewDefaultKeyer()
    policy := DefaultPolicy()
    mw := NewCacheMiddleware(cache, keyer, policy, nil)
    
    ctx := context.Background()
    callCount := 0
    executor := func(ctx context.Context, toolID string, input any) ([]byte, error) {
        callCount++
        return []byte(fmt.Sprintf("result-%d", callCount)), nil
    }
    
    // Different inputs = different keys = cache miss
    result1, _ := mw.Execute(ctx, "ns:tool", map[string]any{"a": 1}, nil, executor)
    result2, _ := mw.Execute(ctx, "ns:tool", map[string]any{"a": 2}, nil, executor)
    
    require.Equal(t, []byte("result-1"), result1)
    require.Equal(t, []byte("result-2"), result2)
    require.Equal(t, 2, callCount)
}

func TestMiddleware_SkipUnsafeTags(t *testing.T) {
    cache := NewMemoryCache(DefaultPolicy())
    keyer := NewDefaultKeyer()
    policy := Policy{DefaultTTL: 5 * time.Minute, AllowUnsafe: false}
    mw := NewCacheMiddleware(cache, keyer, policy, DefaultSkipRule)
    
    ctx := context.Background()
    callCount := 0
    executor := func(ctx context.Context, toolID string, input any) ([]byte, error) {
        callCount++
        return []byte("result"), nil
    }
    
    input := map[string]any{"path": "/tmp/file"}
    
    // Tool tagged "write" should skip caching
    result1, _ := mw.Execute(ctx, "ns:write_file", input, []string{"write"}, executor)
    result2, _ := mw.Execute(ctx, "ns:write_file", input, []string{"write"}, executor)
    
    require.Equal(t, []byte("result"), result1)
    require.Equal(t, []byte("result"), result2)
    require.Equal(t, 2, callCount, "unsafe tool should always execute, never cache")
}

func TestMiddleware_AllUnsafeTags(t *testing.T) {
    cache := NewMemoryCache(DefaultPolicy())
    keyer := NewDefaultKeyer()
    policy := Policy{DefaultTTL: 5 * time.Minute, AllowUnsafe: false}
    mw := NewCacheMiddleware(cache, keyer, policy, DefaultSkipRule)
    
    ctx := context.Background()
    input := map[string]any{}
    
    unsafeTags := []string{"write", "danger", "unsafe", "mutation", "delete"}
    
    for _, tag := range unsafeTags {
        t.Run(tag, func(t *testing.T) {
            callCount := 0
            executor := func(ctx context.Context, toolID string, input any) ([]byte, error) {
                callCount++
                return []byte("result"), nil
            }
            
            mw.Execute(ctx, "ns:tool", input, []string{tag}, executor)
            mw.Execute(ctx, "ns:tool", input, []string{tag}, executor)
            
            require.Equal(t, 2, callCount, "tag %q should skip caching", tag)
        })
    }
}

func TestMiddleware_AllowUnsafeOverride(t *testing.T) {
    cache := NewMemoryCache(DefaultPolicy())
    keyer := NewDefaultKeyer()
    policy := Policy{DefaultTTL: 5 * time.Minute, AllowUnsafe: true} // Allow unsafe
    mw := NewCacheMiddleware(cache, keyer, policy, DefaultSkipRule)
    
    ctx := context.Background()
    callCount := 0
    executor := func(ctx context.Context, toolID string, input any) ([]byte, error) {
        callCount++
        return []byte("result"), nil
    }
    
    input := map[string]any{"path": "/tmp/file"}
    
    // Even with "write" tag, should cache because AllowUnsafe=true
    mw.Execute(ctx, "ns:write_file", input, []string{"write"}, executor)
    mw.Execute(ctx, "ns:write_file", input, []string{"write"}, executor)
    
    require.Equal(t, 1, callCount, "with AllowUnsafe=true, should cache even unsafe tools")
}

func TestMiddleware_CustomSkipRule(t *testing.T) {
    cache := NewMemoryCache(DefaultPolicy())
    keyer := NewDefaultKeyer()
    policy := DefaultPolicy()
    
    // Custom rule: skip tools starting with "private:"
    customRule := func(toolID string, tags []string) bool {
        return strings.HasPrefix(toolID, "private:")
    }
    mw := NewCacheMiddleware(cache, keyer, policy, customRule)
    
    ctx := context.Background()
    callCount := 0
    executor := func(ctx context.Context, toolID string, input any) ([]byte, error) {
        callCount++
        return []byte("result"), nil
    }
    
    // Public tool: should cache
    mw.Execute(ctx, "public:tool", nil, nil, executor)
    mw.Execute(ctx, "public:tool", nil, nil, executor)
    require.Equal(t, 1, callCount)
    
    // Private tool: should skip
    mw.Execute(ctx, "private:tool", nil, nil, executor)
    mw.Execute(ctx, "private:tool", nil, nil, executor)
    require.Equal(t, 3, callCount)
}

func TestMiddleware_ExecutorError(t *testing.T) {
    cache := NewMemoryCache(DefaultPolicy())
    keyer := NewDefaultKeyer()
    policy := DefaultPolicy()
    mw := NewCacheMiddleware(cache, keyer, policy, nil)
    
    ctx := context.Background()
    expectedErr := errors.New("executor failed")
    executor := func(ctx context.Context, toolID string, input any) ([]byte, error) {
        return nil, expectedErr
    }
    
    // Error should propagate, not be cached
    _, err := mw.Execute(ctx, "ns:tool", nil, nil, executor)
    require.ErrorIs(t, err, expectedErr)
    
    // Verify error was not cached (no entry in cache)
    key, _ := keyer.Key("ns:tool", nil)
    _, ok := cache.Get(ctx, key)
    require.False(t, ok, "errors should not be cached")
}

func TestMiddleware_NilResult(t *testing.T) {
    cache := NewMemoryCache(DefaultPolicy())
    keyer := NewDefaultKeyer()
    policy := DefaultPolicy()
    mw := NewCacheMiddleware(cache, keyer, policy, nil)
    
    ctx := context.Background()
    callCount := 0
    executor := func(ctx context.Context, toolID string, input any) ([]byte, error) {
        callCount++
        return nil, nil // Valid nil result
    }
    
    result1, err1 := mw.Execute(ctx, "ns:tool", nil, nil, executor)
    result2, err2 := mw.Execute(ctx, "ns:tool", nil, nil, executor)
    
    require.NoError(t, err1)
    require.NoError(t, err2)
    require.Nil(t, result1)
    require.Nil(t, result2)
    require.Equal(t, 1, callCount, "nil results should be cached")
}

func TestMiddleware_CaseSensitiveTags(t *testing.T) {
    cache := NewMemoryCache(DefaultPolicy())
    keyer := NewDefaultKeyer()
    policy := Policy{DefaultTTL: 5 * time.Minute, AllowUnsafe: false}
    mw := NewCacheMiddleware(cache, keyer, policy, DefaultSkipRule)
    
    ctx := context.Background()
    callCount := 0
    executor := func(ctx context.Context, toolID string, input any) ([]byte, error) {
        callCount++
        return []byte("result"), nil
    }
    
    // Tags should be case-insensitive
    mw.Execute(ctx, "ns:tool", nil, []string{"WRITE"}, executor)
    mw.Execute(ctx, "ns:tool", nil, []string{"WRITE"}, executor)
    
    require.Equal(t, 2, callCount, "WRITE (uppercase) should still skip caching")
}

func TestDefaultSkipRule(t *testing.T) {
    tests := []struct {
        name     string
        toolID   string
        tags     []string
        wantSkip bool
    }{
        {"no tags", "ns:tool", nil, false},
        {"empty tags", "ns:tool", []string{}, false},
        {"safe tag", "ns:tool", []string{"read"}, false},
        {"write tag", "ns:tool", []string{"write"}, true},
        {"danger tag", "ns:tool", []string{"danger"}, true},
        {"unsafe tag", "ns:tool", []string{"unsafe"}, true},
        {"mutation tag", "ns:tool", []string{"mutation"}, true},
        {"delete tag", "ns:tool", []string{"delete"}, true},
        {"mixed tags", "ns:tool", []string{"read", "write"}, true},
        {"uppercase", "ns:tool", []string{"WRITE"}, true},
        {"mixed case", "ns:tool", []string{"WrItE"}, true},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := DefaultSkipRule(tt.toolID, tt.tags)
            require.Equal(t, tt.wantSkip, got)
        })
    }
}
```

**Commit:** `feat(toolcache): add read-through middleware`

---

### Task 6 — Integration Tests

**Files:** `integration_test.go`

**Tests:**

```go
func TestIntegration_EndToEnd(t *testing.T) {
    // Full workflow: keyer + cache + middleware + policy
    cache := NewMemoryCache(DefaultPolicy())
    keyer := NewDefaultKeyer()
    policy := Policy{
        DefaultTTL:  5 * time.Minute,
        MaxTTL:      1 * time.Hour,
        AllowUnsafe: false,
    }
    mw := NewCacheMiddleware(cache, keyer, policy, DefaultSkipRule)
    
    ctx := context.Background()
    
    // Simulate tool execution
    readFileExecutor := func(ctx context.Context, toolID string, input any) ([]byte, error) {
        inputMap := input.(map[string]any)
        path := inputMap["path"].(string)
        return []byte(fmt.Sprintf("content of %s", path)), nil
    }
    
    // First read: cache miss
    result1, err := mw.Execute(ctx, "fs:read_file", map[string]any{"path": "/tmp/test.txt"}, []string{"read"}, readFileExecutor)
    require.NoError(t, err)
    require.Equal(t, []byte("content of /tmp/test.txt"), result1)
    
    // Second read (same input): cache hit
    result2, err := mw.Execute(ctx, "fs:read_file", map[string]any{"path": "/tmp/test.txt"}, []string{"read"}, readFileExecutor)
    require.NoError(t, err)
    require.Equal(t, result1, result2)
}

func TestIntegration_MultipleTools(t *testing.T) {
    cache := NewMemoryCache(DefaultPolicy())
    keyer := NewDefaultKeyer()
    mw := NewCacheMiddleware(cache, keyer, DefaultPolicy(), DefaultSkipRule)
    
    ctx := context.Background()
    
    tool1Calls, tool2Calls := 0, 0
    
    tool1 := func(ctx context.Context, toolID string, input any) ([]byte, error) {
        tool1Calls++
        return []byte("tool1-result"), nil
    }
    tool2 := func(ctx context.Context, toolID string, input any) ([]byte, error) {
        tool2Calls++
        return []byte("tool2-result"), nil
    }
    
    // Different tools, same input
    input := map[string]any{"key": "value"}
    
    mw.Execute(ctx, "ns:tool1", input, nil, tool1)
    mw.Execute(ctx, "ns:tool1", input, nil, tool1) // hit
    mw.Execute(ctx, "ns:tool2", input, nil, tool2)
    mw.Execute(ctx, "ns:tool2", input, nil, tool2) // hit
    
    require.Equal(t, 1, tool1Calls)
    require.Equal(t, 1, tool2Calls)
}
```

**Commit:** `test(toolcache): add integration tests`

---

### Task 7 — Documentation + Examples

**Files:** `README.md`, `docs/index.md`, `docs/user-journey.md`, `example_test.go`

**Example Tests (for documentation):**

```go
func ExampleNewCacheMiddleware() {
    // Create cache components
    cache := NewMemoryCache(DefaultPolicy())
    keyer := NewDefaultKeyer()
    policy := Policy{
        DefaultTTL:  5 * time.Minute,
        AllowUnsafe: false,
    }
    
    // Create middleware
    mw := NewCacheMiddleware(cache, keyer, policy, DefaultSkipRule)
    
    // Define an executor
    executor := func(ctx context.Context, toolID string, input any) ([]byte, error) {
        // Expensive operation here
        return []byte("result"), nil
    }
    
    // Execute with caching
    ctx := context.Background()
    result, err := mw.Execute(ctx, "ns:mytool", map[string]any{"key": "value"}, []string{"read"}, executor)
    if err != nil {
        // handle error
    }
    
    fmt.Println(string(result))
    // Output: result
}

func ExampleDefaultKeyer() {
    keyer := NewDefaultKeyer()
    
    // Generate deterministic keys
    key1, _ := keyer.Key("myns:read_file", map[string]any{"path": "/tmp/file"})
    key2, _ := keyer.Key("myns:read_file", map[string]any{"path": "/tmp/file"})
    
    fmt.Println(key1 == key2)
    // Output: true
}

func ExamplePolicy_EffectiveTTL() {
    policy := Policy{
        DefaultTTL: 5 * time.Minute,
        MaxTTL:     10 * time.Minute,
    }
    
    fmt.Println(policy.EffectiveTTL(0))              // uses default
    fmt.Println(policy.EffectiveTTL(3 * time.Minute)) // uses override
    fmt.Println(policy.EffectiveTTL(15 * time.Minute)) // clamped to max
    // Output:
    // 5m0s
    // 3m0s
    // 10m0s
}
```

**Commit:** `docs(toolcache): finalize documentation`

---

## Quality Gates (Run After Each Task)

```bash
# In toolcache directory
go test -v -race ./...
go test -cover ./...
go vet ./...
```

---

## Commit Order Summary

| # | Commit Message | Files |
|---|----------------|-------|
| 0 | `chore(toolcache): scaffold module and docs` | (already done) |
| 1 | `feat(toolcache): add cache interface and errors` | cache.go, cache_test.go |
| 2 | `feat(toolcache): add deterministic keyer` | keyer.go, keyer_test.go |
| 3 | `feat(toolcache): add ttl policy` | policy.go, policy_test.go |
| 4 | `feat(toolcache): add in-memory backend` | memory.go, memory_test.go |
| 5 | `feat(toolcache): add read-through middleware` | middleware.go, middleware_test.go |
| 6 | `test(toolcache): add integration tests` | integration_test.go |
| 7 | `docs(toolcache): finalize documentation` | README.md, docs/, example_test.go |

---

## Dependencies Between Tasks

```
Task 0 (Scaffold)
    │
    ▼
Task 1 (Cache Interface) ───────────────────┐
    │                                        │
    ▼                                        │
Task 2 (Keyer) ─────────────────────────────┼───┐
    │                                        │   │
    ▼                                        │   │
Task 3 (Policy) ────────────────────────────┤   │
    │                                        │   │
    ▼                                        │   │
Task 4 (Memory Backend) ◄───────────────────┘   │
    │                                            │
    ▼                                            │
Task 5 (Middleware) ◄───────────────────────────┘
    │
    ▼
Task 6 (Integration Tests)
    │
    ▼
Task 7 (Docs)
```

---

## Definition of Done

- [ ] All tasks have tests passing
- [ ] `go test -race ./...` passes
- [ ] `go test -cover ./...` shows >80% coverage
- [ ] `go vet ./...` clean
- [ ] Each task has atomic commit
- [ ] README has working examples
- [ ] Ready for integration with toolrun/toolindex
